// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/whatthefar/monorepo-toolkit/pkg/interactor (interfaces: BuildProjectsOutput)

// Package mock_interactor is a generated GoMock package.
package mock_interactor

import (
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockBuildProjectsOutput is a mock of BuildProjectsOutput interface
type MockBuildProjectsOutput struct {
	ctrl     *gomock.Controller
	recorder *MockBuildProjectsOutputMockRecorder
}

// MockBuildProjectsOutputMockRecorder is the mock recorder for MockBuildProjectsOutput
type MockBuildProjectsOutputMockRecorder struct {
	mock *MockBuildProjectsOutput
}

// NewMockBuildProjectsOutput creates a new mock instance
func NewMockBuildProjectsOutput(ctrl *gomock.Controller) *MockBuildProjectsOutput {
	mock := &MockBuildProjectsOutput{ctrl: ctrl}
	mock.recorder = &MockBuildProjectsOutputMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockBuildProjectsOutput) EXPECT() *MockBuildProjectsOutputMockRecorder {
	return m.recorder
}

// AllBuildSucceeded mocks base method
func (m *MockBuildProjectsOutput) AllBuildSucceeded() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AllBuildSucceeded")
}

// AllBuildSucceeded indicates an expected call of AllBuildSucceeded
func (mr *MockBuildProjectsOutputMockRecorder) AllBuildSucceeded() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllBuildSucceeded", reflect.TypeOf((*MockBuildProjectsOutput)(nil).AllBuildSucceeded))
}

// BuildFailedFor mocks base method
func (m *MockBuildProjectsOutput) BuildFailedFor(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "BuildFailedFor", arg0)
}

// BuildFailedFor indicates an expected call of BuildFailedFor
func (mr *MockBuildProjectsOutputMockRecorder) BuildFailedFor(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildFailedFor", reflect.TypeOf((*MockBuildProjectsOutput)(nil).BuildFailedFor), arg0)
}

// BuildSkippedFor mocks base method
func (m *MockBuildProjectsOutput) BuildSkippedFor(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "BuildSkippedFor", arg0)
}

// BuildSkippedFor indicates an expected call of BuildSkippedFor
func (mr *MockBuildProjectsOutputMockRecorder) BuildSkippedFor(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildSkippedFor", reflect.TypeOf((*MockBuildProjectsOutput)(nil).BuildSkippedFor), arg0)
}

// BuildTriggeredFor mocks base method
func (m *MockBuildProjectsOutput) BuildTriggeredFor(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "BuildTriggeredFor", arg0)
}

// BuildTriggeredFor indicates an expected call of BuildTriggeredFor
func (mr *MockBuildProjectsOutputMockRecorder) BuildTriggeredFor(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildTriggeredFor", reflect.TypeOf((*MockBuildProjectsOutput)(nil).BuildTriggeredFor), arg0)
}

// KillBuildErrorFor mocks base method
func (m *MockBuildProjectsOutput) KillBuildErrorFor(arg0 error, arg1 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "KillBuildErrorFor", arg0, arg1)
}

// KillBuildErrorFor indicates an expected call of KillBuildErrorFor
func (mr *MockBuildProjectsOutputMockRecorder) KillBuildErrorFor(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KillBuildErrorFor", reflect.TypeOf((*MockBuildProjectsOutput)(nil).KillBuildErrorFor), arg0, arg1)
}

// KillingBuildsFor mocks base method
func (m *MockBuildProjectsOutput) KillingBuildsFor(arg0 []string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "KillingBuildsFor", arg0)
}

// KillingBuildsFor indicates an expected call of KillingBuildsFor
func (mr *MockBuildProjectsOutputMockRecorder) KillingBuildsFor(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KillingBuildsFor", reflect.TypeOf((*MockBuildProjectsOutput)(nil).KillingBuildsFor), arg0)
}

// NoBuildTriggeredFor mocks base method
func (m *MockBuildProjectsOutput) NoBuildTriggeredFor(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "NoBuildTriggeredFor", arg0)
}

// NoBuildTriggeredFor indicates an expected call of NoBuildTriggeredFor
func (mr *MockBuildProjectsOutputMockRecorder) NoBuildTriggeredFor(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NoBuildTriggeredFor", reflect.TypeOf((*MockBuildProjectsOutput)(nil).NoBuildTriggeredFor), arg0)
}

// NotFinishedBuildsKilled mocks base method
func (m *MockBuildProjectsOutput) NotFinishedBuildsKilled() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "NotFinishedBuildsKilled")
}

// NotFinishedBuildsKilled indicates an expected call of NotFinishedBuildsKilled
func (mr *MockBuildProjectsOutputMockRecorder) NotFinishedBuildsKilled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotFinishedBuildsKilled", reflect.TypeOf((*MockBuildProjectsOutput)(nil).NotFinishedBuildsKilled))
}

// ThrowError mocks base method
func (m *MockBuildProjectsOutput) ThrowError(arg0 error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ThrowError", arg0)
}

// ThrowError indicates an expected call of ThrowError
func (mr *MockBuildProjectsOutputMockRecorder) ThrowError(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ThrowError", reflect.TypeOf((*MockBuildProjectsOutput)(nil).ThrowError), arg0)
}

// Timeout mocks base method
func (m *MockBuildProjectsOutput) Timeout() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Timeout")
}

// Timeout indicates an expected call of Timeout
func (mr *MockBuildProjectsOutputMockRecorder) Timeout() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Timeout", reflect.TypeOf((*MockBuildProjectsOutput)(nil).Timeout))
}

// WaitingFor mocks base method
func (m *MockBuildProjectsOutput) WaitingFor(arg0 []string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "WaitingFor", arg0)
}

// WaitingFor indicates an expected call of WaitingFor
func (mr *MockBuildProjectsOutputMockRecorder) WaitingFor(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitingFor", reflect.TypeOf((*MockBuildProjectsOutput)(nil).WaitingFor), arg0)
}
